
# HTTP

## HTTP란?

> 전자메일(MIME), 뉴스 그룹 프로토콜이 HTTP의 조상!
Hyper Text Transfer Protocol의 약자로 HTML을 통신하기 위해 만들어짐
애플리케이션 계층으로 웹 서비스 통신에 사용!
> 

HTTP는 header, body로 이루어짐.

### 메서드

[HTTP 요청 메서드 - HTTP | MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Methods)

- GET : 서버에 헤더와 콘텐츠 요청
- HEAD : 서버에 헤더만 요청
- POST : 새로운 문서 투고
- PUT : 이미 존재하는 URL의 문서를 갱신, 목적 리소스 모든 현재 표시를 요청 payload(body)로 바꿈
- DELETE : 지정된 URL 문서 삭제

### 스테이터스 코드

[100 Continue - HTTP | MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Status/100)

- 100번대 : 처리가 진행중 (클라이언트가 서버로 보낸 요청에 문제가 없으니 다음 요청을 보내라)
- 200번대 : 성공했을 때의 응답 (기본적으로 캐시 가능)
- 300번대 : 서버에서 클라이언트로의 명령. 리다이렉션이나 캐시 이용을 지시.
- 400번대 : 잘못된 요청
- 500번대 : 서버 내부 오류

### 리다이렉트

- 300번대의 상태 코드를 지닌 응답으로 location 헤더(URL)를 사용해 리다이렉트할 곳을 서버에서 클라이언트로 즉시 로드시킴
    - 일시적 리다이렉트 (302, 303, 307)
        - 표준 위치에서 접근할 수 없고 다른 위치에서 접근 가능한 경우. 일시적인 기간에 사용할 때(점검 등)
    - 영구적 리다이렉트 (301, 308)
        - 원래 URL이 더 이상 사용되지 않을 때 (새 도메인으로 서버의 컨텐츠를 옮긴 경우, HTTP를 HTTPS로 옮긴 경우)

---

## HTTP/1.0

> 서버로부터 파일을 가져올 때마다 TCP의 3-way 핸드셰이크 열어야 하기 때문에 RTT(응답시간)이 증가.
> 

### 이미지 스플리팅

- 많은 이미지가 합쳐 있는 하나의 이미지를 다운, 이를 기반으로 backgound-image의 position를 이용해 이미지를 표기.

### 코드 압축

- 개행, 공백을 없애 코드의 크기를 최소화.

### 이미지 Base64 인코딩

- 이미지 파일을 64진법으로 이루어진 문자열로 인코딩.
    - 장점 : 서버와의 연결을 열고 이미지에 대해 서버에 HTTP요청이 필요없음
    - 단점 : 37%정도 크기가 더 커짐

---

## HTTP/1.1

> 매번 TCP 연결을 하는 것이 아닌 한 번 TCP를 초기화 후 keep-alive 옵션으로 여러개의 파일을 송수신.
> 

### HOL Blocking

- 네트워크의 같은 큐 내부 패킷이 지연될때, 다른 패킷들도 지연. (통로가 하나라)

### 무거운 헤더 구조

- 쿠키 등 많은 메타 데이터가 들어있고 압축이 되지 않음

---

## HTTP/2

> 지연 시간을 줄이고 응답 시간을 빠르게 하며 멀티플렉싱, 헤더 압축, 서버 푸쉬, 요청의 우선순위 처리 지원
> 

### 멀티 플렉싱

- 여려 개의 스트림을 사용해 송수신. 특정 패킷이 지연, 손실 돼도 나머지 스트림은 정상 전송(HOL Blocking 해결)

### 헤더 압축

- 허프만 코딩 압축 알고리즘을 사용하는 HPACK 압축 형식
    - 문자열을 문자 단위로 쪼개 빈도수가 높은 정보는 적은 비트를 표현해 전체 데이터의 비트양을 줄임

### 서버 푸쉬

- 클라이언트가 서버에 요청없이 리소스를 푸쉬할 수 있음. (html파일에 css, js파일이 포함되면 함께 푸시 원래는 한 요청에 한 파일만 가능)

---

## HTTPS

> HTTP/2는 HTTPS위에서 동작. 
애플리케이션 계층과 전송 계층 사이에 SSL/TLS 계층을 넣은 신뢰 할 수 있는 요청.
> 

### SSL/TLS

- TLS가 최신 버전. 클라이언트와 서버가 통신할 때(전송 계층) 보안 세션을 기반으로 데이터를 암호화. 인증 메커니즘, 키 교환 암호화 알고리즘, 해싱 알고리즘 사용.

### 보안 세션

- 보안이 시작되고 끝나는 동안 유지되는 세션
- 클라이언트와 서버가 공개키로 1-RTT 인증
    1. 클라이언트에서 사이퍼 슈트(cypher suites)를 서버에 전달. 
    2. 서버는 받은 사이퍼 슈트의 암호화 알고리즘 리스트를 제공할 수 있는지 확인. 
    3. 제공할 수 있다면 서버에서 클라이언트로 인증서를 보내는 인증 메커니즘이 시작.
    4. 해싱 알고리즘 등으로 암호화된 데이터 송수신.
- 사이퍼 슈트
    - 프로토콜, AEAD 사이퍼 모드, 해싱 알고리즘이 나열된 규약. 5개가 있음(TLS: 프로토콜, AES_128_GCM: 사이퍼 모드, SHA256: 해싱 알고리즘
        - TLS_AES_128_GCM_SHA256
        - TLS_AES_256_GCM_SHA384
        - TLS_CHACHA20_POLY1305_SHA256
        - TLS_AES_128_CCM_SHA256
        - TLS_AES_128_CCM_8_SHA256
- AED 사이퍼 모드
    - 데이터 암호화 알고리즘.
    - AES_128_GCM → 128비트의 키를 사용하는 표준 블록 암호화 기술과 병렬 계산에 용이한 암호화 알고리즘 GCM이 결합된 알고리즘을 뜻함

### 인증 메커니즘

- CA(Certificate Authorities)에서 발급한 인증서를 기반으로 이루어짐.
    - 자신의 사이트 정보와 공개키를 CA에 제출. 이후 CA에서 공개키를 해시한 값인 지문(finger print)을 사용하는 CA의 비밀키 등을 기반으로 CA인증서를 발급!
- 안전한 연결을 시작하는데 필요한 ‘공개키’를 클라이언트에 제공하고 사용자가 접속한 ‘서버가 신뢰’할 수 있는 서버임을 보장.
- 인증서는 서비스 정보, 공개키, 지문, 디지털 서명 등으로 이루어짐.

### 암호화 알고리즘

- 디피-헬만 키 교환 암호화 알고리즘
    - 암호키를 교환하는 방법중
    공개 값을 공유하고 각자의 비밀 값과 혼합 후 혼합 값을 공유. 그 다음 각자의 비밀값과 또 혼합.
    

### 해싱 알고리즘

- 데이터를 추정하기 힘든 더 작고, 섞여 있는 조각으로 만드는 알고리즘
- SHA-256
    - 해시 함수의 결과값이 256비트인 알고리즘. 해싱 해야 할 메시지에 1을 추가하는 등 전처리 작업 후 해시반환.

<aside>
💡 SEO?
Search Engine Optimization의 약자로 검색엔진 최적화를 뜻함.
검색 결과를 페이지 상단에 노출시켜 많은 사람이 볼 수 있게 최적화하는 방법
- 캐노니컬 설정, 메타 설정, 페이지 속도 개선, 사이트 맵 관리

</aside>

캐노니컬 설정

```html
<link rel="canoniacal" href="https://??.com/page.jsp" />
```

메타 설정

- html의 `<meta>`

### HTTPS 구축 방법

1. 직접 CA에서 구매한 인증키를 기반으로 HTTPS 구축.
2. 서버 앞단에 HTTPS를 제공하는 로드밸런서 구축.
3. 서버 앞단에 HTTPS를 제공하는 CDN 구축.

---

## HTTP/3

> TCP위에서 돌아가는 HTTP/2와 달리 UDP기반의 QUIC이라는 계층 위에서 돌아감
순방향 오류 수정 메커니즘(FEC) 적용. 전송 패킷이 손실되면 수신 측에서 에러를 검출하고 수정하는 방식.
낮은 패킷 손실률을 자랑.
> 

### 초기 연결 설정 시 지연 시간 감소

- TCP를 사용하지 않기 때문에 3-way handshake를 사용하지 않음.
- 첫 연결 설정에 1-RTT만 소요

---

# 추가 공부

## XMLHTTPRequest와 브라우저의 HTTP 요청 차이(AJAX)

비동기인 XMLHTTPRequest을 사용하면

1. 송수신할 때 HTML 화면이 새로 고침 되지 않는다.
2. GET, POST 이외의 메서드도 전송 가능
3. 폼의 경우 키와 같이 일대일 형식의 데이터만 가능하고(Parmeter) 응답은 브라우저로 표시되지만, 플레인 텍스트 JSON, 바이너리 데이터 , XML등 다양한 형식을 송수신 가능.
4. 몇 가지 보안상 제약이 있음.
    1. 엑세스할 수 있는 정보 제한
        - 쿠키 (세션토큰을 httponly 쿠키 속성으로 하면 유출 위험이 줄어듦)
    2. 전송 제한
        - 도메인 : 악의가 있는 웹사이트로 정보를 전송해버리는 문제. CORS (교차 출처 리소스 공유) 엑세스 제한 시스템 사용
        - 메서드 : CONNECT, TRACE, TRACK를 지정해 open()메서드를 호출해 예외를 보내서 악의 적인 페이지를 열었을 때 메일 서버로 스팸 메일 등을 보낼 수 있음. 크로스 사이트 트레이싱 대책 사용
        - 해더
