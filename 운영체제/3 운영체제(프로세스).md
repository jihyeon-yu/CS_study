# 3.운영체제(프로세스)

프로세스

**정의 : 컴퓨터에서 실행되고 있는 프로그램을 말하며 CPU 스케줄링의 대상이 되는 작업(task)라는 용어와 거의 같은 의미로 쓰인다.**

프로그램이 메모리에 올라가면 프로세스가 되는 인스턴스화가 일어나고 cpu가 프로세스를 실행한다.

프로그램은 Disk에 정적으로 존재하는 실행파일

컴파일

컴파일은 고수준 언어를 cpu가 이해할 수 있는 기계어로 번역하는 작업

![Alt text](./img/Untitled.png)

**전처리 과정** 

전처리기를 통해 소스 코드 파일(*.c)을 전처리된 소스 코드 파일(**.i)로 변환하는 과정이다.

전처리기는 소스 코드를 컴파일하기 전에 코드의 일부를 수정하거나 변경하여 컴파일 프로세스를 보다 유연하게 만들어주는 역할을 합니다.

이 과정에서는 대표적으로 세 가지 작업을 수행

주석 제거, 헤더 파일 삽입(#include), 매크로 치환 및 적용(매크로 이름을 찾아서 정의한 값으로 전부 바꿈)

**컴파일(Compilation) 과정**

컴파일러(Compiler)를 통해 전처리된 소스 코드 파일(*.i)을 어셈블리어 파일(*.s)로 변환하는 과정이다.

이 과정에서 우리가 일반적으로 컴파일하면 생각하는 **언어의 문법 검사**가 이루어진다. 또한 **Static한 영역(Data, BSS 영역)들의 메모리 할당**을 수행한다.

컴파일러는 세 단계(프론트엔드-미들엔드-백엔드)로 구성되어 있다.

**어셈블리어란?**

기계어는 다른 말로 명령어(Machine Instruction)이라고 부르는데 명령어는 0101010과 같은 이진수로 이뤄진 숫자로 CPU 종류마다 고유한 내용을 가지고 있다.

**어셈블리어**는 이런 명령어를 **사람이 이해할 수 있게 부호화**한 것으로 **CPU 명령어(기계어)와 1대1로 매칭**된다.

어셈블리 과정

**어셈블리(Assembly) 과정**은 어셈블러(Assembler)를 통해 어셈블리어 파일(*.s)을 오브젝트 파일(*.o)로 변환하는 과정이다.

오브젝트 파일이란 무엇일까?

어셈블리 코드는 이제 더 이상 사람이 알아볼 수 없는 기계어로 변환되는데 이를 오브젝트 코드라 부른다.

링킹 과정

링커(Linker)를 통해 오브젝트 파일(*.o)들을 묶어 실행 파일로 만드는 과정이다.

이 과정에서 **오브젝트 파일들**과 프로그램에서 사용하는 **라이브러리 파일들**을 **링크**하여 **하나의 실행 파일**을 만든다.

라이브러리

**프로그래밍에 사용할 수 있게 미리 만들어져 있는 함수나 변수들의 묶음**이다. 미리 컴파일된 오프젝트 파일 형태로 존재하며 컴파일 과정(링킹 과정)에서 링킹되어 실행 가능한 프로그램을 이룬다.

컴파일 과정 동안 연쇄적으로 사용하는 **개발 도구들(전처리기-컴파일러-어셈블리-링커)**을 묶어서 **툴체인(Toolchain)**이라고도 부른다.

![Alt text](./img/Untitled%201.png)

UNIX 시스템은 프로세스에 4GB의 가상메모리를 할당, 하위 3GB를 사용자가, 상위 1GB 커널이 차지하게 됩니다. 사용자가 사용하는 부분을 자세히 살펴보겠습니다.

메모리 구조

![Alt text](./img/Untitled%202.png)

### Code 영역

**실행할 프로그램의 코드**가 저장됩니다. CPU는 이 영역에서 명령어를 하나씩 가져와 처리하게 됩니다.

### Data 영역

**전역변수와 정적변수**가 저장됩니다. 이 변수들은 프로그램이 시작될 때 할당되어 프로그램 종료 시 소멸됩니다.

+) 더 자세히 들어가면 BSS(Block Stated Symbol) 영역이 있는데요, 이 영역에는 초기화 되지 않은 전역변수가 저장됩니다. 초기화 된 전역변수는 Data 영역에 저장되어 비휘발성 메모리인 ROM에 저장되는데 이 부분은 비용이 많이 들어 RAM에 저장될 것과 ROM에 저장될 것을 구분하기 위해 영역을 구분해 사용합니다.

### Stack 영역

지연변수, 매개변수, 리턴값 등 **잠시 사용되었다가 사라지는 데이터**를 저장하는 영역입니다. 함수 호출 시 할당되고 함수 반환 시 소멸됩니다. 로드 시(컴파일 타임) 크기가 결정됩니다.

위 세 영역은 컴파일 할 때 data, stack 영역의 크기를 계산해 메모리 영역을 결정합니다!

### Heap 영역

**동적 데이터 영역**입니다. 메모리 주소 값에 의해서만 참조되고 사용되는 영역입니다. 따라서, *프로그램 동작 시(런타임)에 크기가 결정*됩니다.

예를 들어, stack에서 pointer 변수를 할당하면 pointer가 가리키는 heap 영역의 임의의 공간부터 원하는 크기만큼 할당해 사용하게 됩니다.

프로세스 제어블록(PCB, Process Control Block)이란 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보를 담는 커널 내의 자료구조를 뜻합니다. 프로세스의 상태 관리와 문맥 교환 때문에 필요합니다.

- 프로세스 생성 시 PCB 생성
- 프로세스 종료 시 PCB 제거

![Alt text](./img/Untitled%203.png)

![Alt text](./img/Untitled%204.png)

![Alt text](./img/Untitled%205.png)

![Alt text](./img/Untitled%206.png)

IPC

```
독립적인 프로세스는 데이터를 공유할 일도 없고, 메시지를 주고 받을 일도 없기 때문에 문제가 발생하지 않는다.
그냥 따로 메모리 영역을 가지고 있고, 자기 일을 자기가 알아서 한다.이럴 경우에는 CPU 스케쥴링을 잘해주면 영향을 안 미치고 자기들끼리 잘 공존한다.
하지만 문제는 협력적인 프로세스일때 문제가 발생한다.우선 프로세스 간의 협력이 필요한 이유는
정보 공유 (Information sharing) : 여러 사용자가 동일한 정보를 필요로 할 수 있다.
계산 가속화 (Computation speedup) : 특정 작업(task)를 빠르게 실행하기 위해, 해당 작업을 부분 작업(서브 태스크)으로 나눠서 병렬로 실행하게 할 수 있다.
모듈성 (Modularity) : 특정한 시스템 기능을 별도의 프로세스(스레드)로 구분하여 모듈식 형태로 시스템을 구성할 수 있다.
편의성 (Convenience) : 여러 사용자들이 동시에 많은 작업을 수행할 수 있다.4가지로 볼 수 있다.하지만 부모 프로세스와 자식 프로세스간에 메시지를 주고받을 때 서로 공유하는 상황이기 때문에 문제가 발생한다.
즉, 프로세스들간의 데이터를 공유하고 메시지를 주고 받을 때 문제가 생기고, "이것을 어떻게 해결할 것인가?"에 관한 것이 IPC라고 할 수 있다.
```

출처:

[https://junghyungil.tistory.com/146](https://junghyungil.tistory.com/146)

[인생을 코딩하다.:티스토리]
